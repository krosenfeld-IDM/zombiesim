{'previous': 'import matplotlib.pyplot as pl', 'new': 'import matplotlib.pyplot as plt'},
{'previous': '', 'new': 'import sciris as sc'},
{'previous': 'self.default_pars(\n            beta = 0.1,\n            init_prev = ss.bernoulli(p=0.01),\n            dur_inf = ss.lognorm_ex(mean=6),\n            p_death = ss.bernoulli(p=0.01),\n        )', 'new': 'self.define_pars(\n            beta = ss.beta(0.1),\n            init_prev = ss.bernoulli(p=0.01),\n            dur_inf = ss.lognorm_ex(mean=ss.dur(6)),\n            p_death = ss.bernoulli(p=0.01),\n        )'},
{'previous': "self.add_states(\n            ss.BoolArr('recovered'),\n            ss.FloatArr('ti_recovered'),\n            ss.FloatArr('ti_dead'),\n        )", 'new': "self.define_states(\n            ss.State('susceptible', default=True, label='Susceptible'),\n            ss.State('infected', label='Infectious'),\n            ss.State('recovered', label='Recovered'),\n            ss.FloatArr('ti_infected', label='Time of infection'),\n            ss.FloatArr('ti_recovered', label='Time of recovery'),\n            ss.FloatArr('ti_dead', label='Time of death'),\n            ss.FloatArr('rel_sus', default=1.0, label='Relative susceptibility'),\n            ss.FloatArr('rel_trans', default=1.0, label='Relative transmission'),\n        )"},
{'previous': 'def update_pre(self):', 'new': 'def step_state(self):'},
{'previous': 'def set_prognoses(self, uids, source_uids=None):', 'new': 'def set_prognoses(self, uids, sources=None):'},
{'previous': 'super().set_prognoses(uids, source_uids)', 'new': 'super().set_prognoses(uids, sources)'},
{'previous': 'dt = self.sim.dt', 'new': 'ti = self.t.ti'},
{'previous': 'self.ti_dead[dead_uids] = ti + dur_inf[will_die] / dt # Consider rand round, but not CRN safe\nself.ti_recovered[rec_uids] = ti + dur_inf[~will_die] / dt', 'new': 'self.ti_dead[dead_uids] = ti + dur_inf[will_die] # Consider rand round, but not CRN safe\nself.ti_recovered[rec_uids] = ti + dur_inf[~will_die]'},
{'previous': 'def update_death(self, uids):', 'new': 'def step_die(self, uids):'},
{'previous': 'def plot(self):', 'new': 'def plot(self, **kwargs):'},
{'previous': 'fig = pl.figure()', 'new': 'fig = plt.figure()'},
{'previous': "for rkey in ['susceptible', 'infected', 'recovered']:", 'new': "for rkey in ['n_susceptible', 'n_infected', 'n_recovered']:"},
{'previous': 'pl.legend()', 'new': 'plt.legend(frameon=False)'},
{'previous': 'return fig', 'new': 'return ss.return_fig(fig)'},
{'previous': 'self.default_pars(\n            beta = 0.05,\n            init_prev = ss.bernoulli(p=0.01),\n            dur_inf = ss.lognorm_ex(mean=10),\n            waning = 0.05,\n            imm_boost = 1.0,\n        )', 'new': 'self.define_pars(\n            beta = ss.beta(0.05),\n            init_prev = ss.bernoulli(p=0.01),\n            dur_inf = ss.lognorm_ex(mean=ss.dur(10)),\n            waning = ss.rate(0.05),\n            imm_boost = 1.0,\n        )'},
{'previous': "self.add_states(\n             ss.FloatArr('ti_recovered'),\n             ss.FloatArr('immunity', default=0.0),\n         )", 'new': "self.define_states(\n             ss.FloatArr('ti_recovered'),\n             ss.FloatArr('immunity', default=0.0),\n         )"},
{'previous': 'self.ti_infected[uids] = self.sim.ti', 'new': 'self.ti_infected[uids] = self.ti'},
{'previous': 'self.ti_recovered[uids] = self.sim.ti + dur_inf / self.sim.dt', 'new': 'self.ti_recovered[uids] = self.ti + dur_inf'},
{'previous': "self.results += ss.Result(self.name, 'rel_sus', self.sim.npts, dtype=float)", 'new': "self.define_results(\n            ss.Result('rel_sus', dtype=float, label='Relative susceptibility')\n        )"},
{'previous': "self.results['rel_sus'][self.sim.ti] = self.rel_sus.mean()", 'new': "self.results['rel_sus'][self.ti] = self.rel_sus.mean()"},
{'previous': 'fig = pl.figure()', 'new': 'fig = plt.figure()'},
{'previous': "for rkey in ['susceptible', 'infected']:", 'new': "for rkey in ['n_susceptible', 'n_infected']:"},
{'previous': 'return fig', 'new': 'return ss.return_fig(fig)'},
{'previous': 'self.default_pars(\n            efficacy = 0.9,\n            leaky = True\n        )', 'new': 'self.define_pars(\n            efficacy = 0.9,\n            leaky = True\n        )'}